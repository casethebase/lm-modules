{
  "id" : 72036646,
  "description" : "Linux Control Groups status monitoring via the systemd-cgtop command.",
  "group" : "",
  "appliesTo" : "hasCategory(\"Linux_SSH\") || ssh.user && ssh.pass && isLinux()",
  "technology" : "Systemd resource monitoring requires that CPUAccounting be enabled in the  systemd-system.conf configuration file. See documentation for setup instructions.",
  "tags" : "linux,control groups,ssh,services,status",
  "checksum" : "5b5fdbb7c7eb5e5cbba44ba4f45d31ee",
  "lineageId" : "pb9K_nu6TSSn26jvSTJm6A",
  "name" : "Linux_SSH_CGroupStatus",
  "displayName" : "Linux SSH CGroupStatus",
  "version" : 1592227304,
  "auditVersion" : 0,
  "hasMultiInstances" : false,
  "collectInterval" : 300,
  "collectMethod" : "batchscript",
  "collectorAttribute" : {
    "name" : "batchscript",
    "linuxCmdline" : "",
    "linuxScript" : "",
    "groovyScript" : "/*******************************************************************************\n *  Â© 2007-2020 - LogicMonitor, Inc. All rights reserved.\n ******************************************************************************/\n\nimport com.jcraft.jsch.JSch\nimport com.santaba.agent.util.Settings\n\n// Gather credentials from host -> \nhost = hostProps.get(\"system.hostname\")\nuser = hostProps.get(\"ssh.user\")\npass = hostProps.get(\"ssh.pass\")\nport = hostProps.get(\"ssh.port\") ?: 22\ncert = hostProps.get(\"ssh.cert\") ?: '~/.ssh/id_rsa'\ntimeout = 15000 // timeout in milliseconds\n// <- \n\n\ndef datamap = [:]\n\ndef ssh_cmd = \"systemd-cgtop -n2 -b --raw\\n\";\ndef output = getCommandOutput(ssh_cmd).readLines()\n\noutput.each {\n        \n\tline->\n    String delims = \"[ ]+\";\n    String[] tokens = line.split(delims);\n        \n    if (tokens.size() < 4) {\n        return\n    }\n\n    def instance = tokens[0].replaceAll(/[:|\\\\|\\s|=]+/,\"_\")\n\n    def data = tokens[2].replace('-',\"\")\n\n    if (instance != \"/\") {\n        datamap[instance] = data  \n    }\n         \n}\n\n\ndef systemdConnectionStatus = 1\ndef unitsTotal = datamap.size()\n\nprintln \"unitsTotal=$unitsTotal\"\n\nif (unitsTotal < 1) {\n    systemdConnectionStatus = 1\n    return 1\n    println \"Failed connection to systemd\"\n}\n\nif (unitsTotal > 1) {\n    systemdConnectionStatus = 0\n    return 0\n}\n\n\ndef getCommandOutput(String input_command) {\n\n    try {\n        // instantiate JSCH object.\n        jsch = new JSch()\n\n        // do we have an user and no pass ?\n        if (user && !pass) {\n            // Yes, so lets try connecting via cert.\n            jsch.addIdentity(cert)\n        }\n\n        // create session.\n        session = jsch.getSession(user, host, port)\n\n        // given we are running non-interactively, we will automatically accept new host keys.\n        session.setConfig(\"StrictHostKeyChecking\", \"no\");\n        String authMethod = Settings.getSetting(Settings.SSH_PREFEREDAUTHENTICATION, Settings.DEFAULT_SSH_PREFEREDAUTHENTICATION);\n        session.setConfig(\"PreferredAuthentications\", authMethod);\n\n        // set session timeout, in milliseconds.\n        session.setTimeout(timeout)\n\n        // is host configured with a user & password?\n        if (pass) {\n            // set password.\n            session.setPassword(pass);\n        }\n\n        // connect\n        session.connect()\n\n        // execute command.\n        channel = session.openChannel(\"exec\")\n        channel.setCommand(input_command)\n\n        // collect command output.\n        def commandOutput = channel.getInputStream()\n        channel.connect()\n\n        def output = commandOutput.text;\n\n        // disconnect\n        channel.disconnect()\n\n        return output\n    }\n    catch (Exception e) {\n        e.printStackTrace()\n    }\n    // ensure we disconnect the session.\n    finally {\n        session.disconnect()\n    }\n}",
    "scriptType" : "embed",
    "windowsCmdline" : "",
    "windowsScript" : ""
  },
  "enableAutoDiscovery" : false,
  "autoDiscoveryConfig" : null,
  "dataPoints" : [ {
    "id" : 37240,
    "dataSourceId" : 72036646,
    "name" : "SystemdConnectionStatus",
    "description" : "Status of connection tosystemd on given host.",
    "alertTransitionInterval" : 0,
    "alertClearTransitionInterval" : 0,
    "type" : 2,
    "dataType" : 7,
    "maxDigits" : 4,
    "postProcessorMethod" : "namevalue",
    "postProcessorParam" : "##WILDVALUE##.ConnectionStatus",
    "rawDataFieldName" : "output",
    "maxValue" : "1",
    "minValue" : "0",
    "userParam1" : "",
    "userParam2" : "",
    "userParam3" : "",
    "alertForNoData" : 1,
    "alertExpr" : "!= 0",
    "alertExprNote" : "",
    "alertSubject" : "",
    "alertBody" : "Systemd on ##HOST## is not in a connected operating state and is reporting a status code of ##VALUE##, placing the host into ##LEVEL## state.\n\nStatus Codes:\n0 = OK,\n1 = Connection failed\n\nThis started at ##START## , -- or ##DURATION## ago.",
    "enableAnomalyAlertSuppression" : "",
    "adAdvSettingEnabled" : false,
    "warnAdAdvSetting" : "",
    "errorAdAdvSetting" : "",
    "criticalAdAdvSetting" : ""
  }, {
    "id" : 37241,
    "dataSourceId" : 72036646,
    "name" : "unitsTotal",
    "description" : "Total number of CGroups being monitored",
    "alertTransitionInterval" : 0,
    "alertClearTransitionInterval" : 0,
    "type" : 2,
    "dataType" : 7,
    "maxDigits" : 4,
    "postProcessorMethod" : "namevalue",
    "postProcessorParam" : "##WILDVALUE##.unitsTotal",
    "rawDataFieldName" : "output",
    "maxValue" : "",
    "minValue" : "",
    "userParam1" : "",
    "userParam2" : "",
    "userParam3" : "",
    "alertForNoData" : 1,
    "alertExpr" : "",
    "alertExprNote" : "",
    "alertSubject" : "",
    "alertBody" : "",
    "enableAnomalyAlertSuppression" : "",
    "adAdvSettingEnabled" : false,
    "warnAdAdvSetting" : "",
    "errorAdAdvSetting" : "",
    "criticalAdAdvSetting" : ""
  } ],
  "enableEriDiscovery" : false,
  "eriDiscoveryInterval" : -1,
  "eriDiscoveryConfig" : null
}