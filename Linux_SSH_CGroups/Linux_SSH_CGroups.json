{
  "id" : 70213436,
  "description" : "Linux Control Groups resource and task usage via the systemd-cgtop command.",
  "group" : "",
  "appliesTo" : "hasCategory(\"Linux_SSH\") || ssh.user && ssh.pass && isLinux()",
  "technology" : "Requires manually modifying active discovery script for auto-discovery to take place.\n\nFlag for manually enabling Active Discovery. Change value to 'true' to auto-discover instances. \n\n'def enableAD = false'\n\nRefer to documentation before editing.",
  "tags" : "cgroups,systemd,linux,control groups,ssh",
  "checksum" : "378911d63655f8e8fe6f7f65b27aee90",
  "lineageId" : "DMP2drA5QEa-jTHZoWl-CQ",
  "name" : "Linux_SSH_CGroups",
  "displayName" : "Linux SSH CGroups",
  "version" : 1592229932,
  "auditVersion" : 0,
  "hasMultiInstances" : true,
  "collectInterval" : 300,
  "collectMethod" : "batchscript",
  "collectorAttribute" : {
    "name" : "batchscript",
    "linuxCmdline" : "",
    "linuxScript" : "",
    "groovyScript" : "/*******************************************************************************\r\n *  © 2007-2020 - LogicMonitor, Inc. All rights reserved.\r\n ******************************************************************************/\r\n\r\nimport com.jcraft.jsch.JSch\r\nimport com.santaba.agent.util.Settings\r\n\r\n// Gather credentials from host -> \r\nhost = hostProps.get(\"system.hostname\")\r\nuser = hostProps.get(\"ssh.user\")\r\npass = hostProps.get(\"ssh.pass\")\r\nport = hostProps.get(\"ssh.port\") ?: 22\r\ncert = hostProps.get(\"ssh.cert\") ?: '~/.ssh/id_rsa'\r\ntimeout = 15000 // timeout in milliseconds\r\n// <- \r\n\r\n\r\ndef cpuDatamap = [:]\r\ndef memDatamap = [:]\r\ndef taskDatamap = [:]\r\n\r\ndef ssh_cmd = \"systemd-cgtop -n2 -b --raw\\n\";\r\ndef output = getCommandOutput(ssh_cmd).readLines()\r\n\r\noutput.each {\r\n\r\n\tline->\r\n    String delims = \"[ ]+\";\r\n    String[] tokens = line.split(delims);\r\n   \r\n    if (tokens.size() < 4) {\r\n        return\r\n    }\r\n\r\n    def instance = tokens[0].replaceAll(/[:|\\\\|\\s|=]+/,\"_\")\r\n\r\n    def cpu = tokens[2].replace('-',\"\")\r\n    def mem = tokens[3].replace('-',\"\")\r\n    def tasks = tokens[1].replace('-',\"\")\r\n\r\n    if (instance != \"/\") {\r\n        cpuDatamap[instance] = cpu\r\n        memDatamap[instance] = mem\r\n        taskDatamap[instance] = tasks   \r\n    }\r\n \r\n}\r\n\r\ncpuDatamap.each { k, v ->\r\n    println \"${k}.cpu=\" + v\r\n}\r\n\r\nmemDatamap.each { k, v ->\r\n    println \"${k}.mem=\" + v\r\n}\r\n\r\ntaskDatamap.each { k, v ->\r\n    println \"${k}.tasks=\" + v\r\n}\r\n\r\nreturn 0\r\n\r\ndef getCommandOutput(String input_command) {\r\n\r\n    try {\r\n        // instantiate JSCH object.\r\n        jsch = new JSch()\r\n\r\n        // do we have an user and no pass ?\r\n        if (user && !pass) {\r\n            // Yes, so lets try connecting via cert.\r\n            jsch.addIdentity(cert)\r\n        }\r\n\r\n        // create session.\r\n        session = jsch.getSession(user, host, port)\r\n\r\n        // given we are running non-interactively, we will automatically accept new host keys.\r\n        session.setConfig(\"StrictHostKeyChecking\", \"no\");\r\n        String authMethod = Settings.getSetting(Settings.SSH_PREFEREDAUTHENTICATION, Settings.DEFAULT_SSH_PREFEREDAUTHENTICATION);\r\n        session.setConfig(\"PreferredAuthentications\", authMethod);\r\n\r\n        // set session timeout, in milliseconds.\r\n        session.setTimeout(timeout)\r\n\r\n        // is host configured with a user & password?\r\n        if (pass) {\r\n            // set password.\r\n            session.setPassword(pass);\r\n        }\r\n\r\n        // connect\r\n        session.connect()\r\n\r\n        // execute command.\r\n        channel = session.openChannel(\"exec\")\r\n        channel.setCommand(input_command)\r\n\r\n        // collect command output.\r\n        def commandOutput = channel.getInputStream()\r\n        channel.connect()\r\n\r\n        def output = commandOutput.text;\r\n\r\n        // disconnect\r\n        channel.disconnect()\r\n\r\n        return output\r\n    }\r\n    catch (Exception e) {\r\n        e.printStackTrace()\r\n    }\r\n    // ensure we disconnect the session.\r\n    finally {\r\n        session.disconnect()\r\n    }\r\n}",
    "scriptType" : "embed",
    "windowsCmdline" : "",
    "windowsScript" : ""
  },
  "enableAutoDiscovery" : true,
  "autoDiscoveryConfig" : {
    "persistentInstance" : false,
    "disableInstance" : false,
    "deleteInactiveInstance" : true,
    "instanceAutoGroupMethod" : "none",
    "instanceAutoGroupMethodParams" : "",
    "scheduleInterval" : 15,
    "method" : {
      "name" : "ad_script",
      "type" : "embeded",
      "winScript" : null,
      "winCmdline" : null,
      "linuxCmdline" : null,
      "linuxScript" : null,
      "groovyScript" : "/*******************************************************************************\r\n *  © 2007-2020 - LogicMonitor, Inc. All rights reserved.\r\n ******************************************************************************/\r\n\r\nimport com.jcraft.jsch.JSch\r\nimport com.santaba.agent.util.Settings\r\n\r\nhost = hostProps.get(\"system.hostname\")\r\nuser = hostProps.get(\"ssh.user\")\r\npass = hostProps.get(\"ssh.pass\")\r\nport = hostProps.get(\"ssh.port\") ?: 22\r\ncert = hostProps.get(\"ssh.cert\") ?: '~/.ssh/id_rsa'\r\ntimeout = 15000 // timeout in milliseconds\r\n\r\n// Flag for manually enabling Active Discovery. Change value to 'true' to auto-discover instances. \r\ndef enableAD = false\r\n// Refer to documentation and technical notes before changing this value.\r\n\r\n\r\ndef ssh_cmd = \"systemd-cgtop -b --raw\\n\";\r\ndef output = getCommandOutput(ssh_cmd).readLines()\r\n\r\noutput.each {\r\n    \r\n\tline->\r\n        String delims = \"[ ]+\";\r\n        String[] tokens = line.split(delims);\r\n\r\n        // change .'s and /s to underscores\r\n        def instance = tokens[0].replaceAll(/[:|\\\\|\\s|=]+/,\"_\")\r\n\r\n        // removing underscore because first line of cgtop is a total of all instances\r\n        if (enableAD = true) {\r\n            if (instance != \"/\"){\r\n                println \"$instance##$instance##\"\r\n            }\r\n        }\r\n}\r\n\r\nreturn 0\r\n\r\n\r\ndef getCommandOutput(String input_command) {\r\n    try {\r\n        // instantiate JSCH object.\r\n        jsch = new JSch()\r\n\r\n        // do we have an user and no pass ?\r\n        if (user && !pass) {\r\n            // Yes, so lets try connecting via cert.\r\n            jsch.addIdentity(cert)\r\n        }\r\n\r\n        // create session.\r\n        session = jsch.getSession(user, host, port)\r\n\r\n        // given we are running non-interactively, we will automatically accept new host keys.\r\n        session.setConfig(\"StrictHostKeyChecking\", \"no\");\r\n        String authMethod = Settings.getSetting(Settings.SSH_PREFEREDAUTHENTICATION, Settings.DEFAULT_SSH_PREFEREDAUTHENTICATION);\r\n        session.setConfig(\"PreferredAuthentications\", authMethod);\r\n\r\n        // set session timeout, in milliseconds.\r\n        session.setTimeout(timeout)\r\n\r\n        // is host configured with a user & password?\r\n        if (pass) {\r\n            // set password.\r\n            session.setPassword(pass);\r\n        }\r\n\r\n        // connect\r\n        session.connect()\r\n\r\n        // execute command.\r\n        channel = session.openChannel(\"exec\")\r\n        channel.setCommand(input_command)\r\n\r\n        // collect command output.\r\n        def commandOutput = channel.getInputStream()\r\n        channel.connect()\r\n\r\n        def output = commandOutput.text;\r\n\r\n        // disconnect\r\n        channel.disconnect()\r\n\r\n        return output\r\n    }\r\n    catch (Exception e) {\r\n        e.printStackTrace()\r\n    }\r\n    // ensure we disconnect the session.\r\n    finally {\r\n        session.disconnect()\r\n    }\r\n}"
    },
    "filters" : [ ]
  },
  "dataPoints" : [ {
    "id" : 36363,
    "dataSourceId" : 70213436,
    "name" : "CPU",
    "description" : "CPU resource consumption measured as percentage, across multiple cores",
    "alertTransitionInterval" : 0,
    "alertClearTransitionInterval" : 0,
    "type" : 2,
    "dataType" : 7,
    "maxDigits" : 4,
    "postProcessorMethod" : "namevalue",
    "postProcessorParam" : "##WILDVALUE##.cpu",
    "rawDataFieldName" : "output",
    "maxValue" : "",
    "minValue" : "",
    "userParam1" : "",
    "userParam2" : "",
    "userParam3" : "",
    "alertForNoData" : 1,
    "alertExpr" : "",
    "alertExprNote" : "",
    "alertSubject" : "",
    "alertBody" : "",
    "enableAnomalyAlertSuppression" : "",
    "adAdvSettingEnabled" : false,
    "warnAdAdvSetting" : "",
    "errorAdAdvSetting" : "",
    "criticalAdAdvSetting" : ""
  }, {
    "id" : 36364,
    "dataSourceId" : 70213436,
    "name" : "MemoryUsage",
    "description" : "Memory resource usage measured in bytes",
    "alertTransitionInterval" : 0,
    "alertClearTransitionInterval" : 0,
    "type" : 2,
    "dataType" : 7,
    "maxDigits" : 4,
    "postProcessorMethod" : "namevalue",
    "postProcessorParam" : "##WILDVALUE##.mem",
    "rawDataFieldName" : "output",
    "maxValue" : "",
    "minValue" : "0",
    "userParam1" : "",
    "userParam2" : "",
    "userParam3" : "",
    "alertForNoData" : 1,
    "alertExpr" : "",
    "alertExprNote" : "",
    "alertSubject" : "",
    "alertBody" : "",
    "enableAnomalyAlertSuppression" : "",
    "adAdvSettingEnabled" : false,
    "warnAdAdvSetting" : "",
    "errorAdAdvSetting" : "",
    "criticalAdAdvSetting" : ""
  }, {
    "id" : 36373,
    "dataSourceId" : 70213436,
    "name" : "TaskCount",
    "description" : "Total number of tasks assigned to each control group",
    "alertTransitionInterval" : 0,
    "alertClearTransitionInterval" : 0,
    "type" : 2,
    "dataType" : 7,
    "maxDigits" : 4,
    "postProcessorMethod" : "namevalue",
    "postProcessorParam" : "##WILDVALUE##.tasks",
    "rawDataFieldName" : "output",
    "maxValue" : "",
    "minValue" : "",
    "userParam1" : "",
    "userParam2" : "",
    "userParam3" : "",
    "alertForNoData" : 1,
    "alertExpr" : "",
    "alertExprNote" : "",
    "alertSubject" : "",
    "alertBody" : "",
    "enableAnomalyAlertSuppression" : "0,0,0",
    "adAdvSettingEnabled" : false,
    "warnAdAdvSetting" : "",
    "errorAdAdvSetting" : "",
    "criticalAdAdvSetting" : ""
  } ],
  "enableEriDiscovery" : false,
  "eriDiscoveryInterval" : -1,
  "eriDiscoveryConfig" : null
}